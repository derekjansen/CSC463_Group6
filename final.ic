#define lMotor 0
#define rMotor 2

#define clawMotor 3

#define lLine 2
#define rLine 3

#define lLightPhoto 4
#define rLightPhoto 5

//#define reflecto 6 

#define lightThresh 100
#define lineThresh 50
#define reflectoThresh 20

void main()
{
    while(1)
      { 
        //forward
        forward();
        followLine();
        searchForBlocks();
        
        //if you are at an intersection search for blocks
        /*if(analog(lLine) >= lineThresh && analog(rLine) >= lineThresh)
          {
            //searchForBlocks(); 
        beep();
        stop();
        }*/
        
        //figure out how to determine if we are at the end of the maze and can drop the block
    }
}

void followLine()
{   
    //adjust right
    if(analog(rLine) >= lineThresh)
      {
        motor(lMotor, 20);
        motor(rMotor, 70);
        while(analog(rLine) > lineThresh)
          {
            sleep(0.1);
        }
    }
    
    //adjust left
    if(analog(lLine) >= lineThresh)
      {
        motor(lMotor,70);
        motor(rMotor,20);
        while(analog(lLine) > lineThresh)
          {
            sleep(0.1);
        }
    }
}

void searchForBlocks()
{
    //if there is a light on the left
    if(analog(lLightPhoto) > lightThresh)
      {
        //turn left and go to the block
        correct();
        left();
        //drive to the block
        
        /*while(analog(reflecto) > reflectoThresh)
          {
            forward();
        }*/
        //close the claw
        closeClaw();
        //turn around
        left();
        left();
        
        //go back to the line
        while(analog(rLine) < lineThresh && analog(lLine) < lineThresh)
          {
            forward();
        }
        
        //turn left
        left();
        
        deliverBlock();
    }
    
    //if there is a light on the right
    if(analog(rLightPhoto) > lightThresh)
      {
        //turn right
        correct();
        right();
        //forward to the block
        while(analog(reflecto) > reflectoThresh)
          {
            forward();
        }
        //close the claw
        closeClaw(); 
        
        //turn around
        left();
        left();
        
        //go back to the line
        while(analog(rLine) < lineThresh && analog(lLine) < lineThresh)
          {
            forward();
        }
        
        //turn right
        right();
        
        deliverBlock();
        
    }
}

void deliverBlock()
{
    //travel to end of maze
    while(analog(reflecto) > reflectoThresh)
      {
        followLine();
    }
    //drop block
    openClaw();
    //backup
    backup();
    sleep(0.5);
    //turn around
    left();
    left();
    //go back to start
    while(analog(reflecto) > reflectoThresh)
      {
        followLine();
    }
    //turn around
    left();
    left();
}

void correct()
{
    forward();
    sleep(1.5);
}

void left()
{
    motor(rMotor, -75);
    motor(lMotor, 75);
    sleep(1.85);
}

void right()
{
    motor(rMotor, 75);
    motor(lMotor, -75);
    sleep(1.85);
}

void backup()
{
    motor(lMotor, -50);
    motor(rMotor, -50);
}

void forward()
{
    motor(lMotor, 50);
    motor(rMotor, 50);
}

void stop()
{
    motor(lMotor, 0);
    motor(rMotor, 0);
}

void openClaw()
{
    motor(clawMotor, 25);
    sleep(0.3);
    motor(clawMotor, 0);
}

void closeClaw()
{
    motor(clawMotor, -25);
    sleep(0.3);
    motor(clawMotor, 0);
}
